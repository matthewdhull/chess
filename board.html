  <!DOCTYPE html>
<head>
  <title>board</title>
  <meta charset="utf-8">
  <link rel="shortcut icon" href="">
  <style>
	
	 body {
		 display: grid;
	 }
	 	  
	  * {
		  font-family: sans-serif;
	  }
	 svg g text {
		 font-size: 9pt;
	 }
	 
	 svg {
	 	/*place svg element above button */
		 grid-row-start: 1; 
	 }
	 
	 #start {
	 	grid-row-start: 2;
	 	width: 50px;
	 	height: 20px;
	 }
	 
	 #positionDisplay{
		 grid-row-start: 3;		 
	 }
	 
	 
	 #selectGame {
		 grid-row-start: 1;
		 grid-column-start: 2;
	 }
	 

	 #moves {
		 display: grid;
		 grid-template-columns: repeat(2, 85px);  		 
		 width: 433px;
		 height: 433px;
		 line-height: 25px;
		 overflow: scroll;
	 }
	 
	 #moves div {
		 margin: 2px;
		 padding: 2px;
	 }
	 


	 
  </style>
 </head>
<body>

<button id="start">Move</button>

<div id="positionDisplay">(hover) Position:</div>

<div id="selectGame">
<label for="gameSelect">Select Game:</label>
<select name="gameSelect" id="gameSelect">
	<option value="data/kasparovVkarpov.json">Kasparov v. Karpov</option>	
	<option value="data/fischerVreshevsky.json">Fischer v. Reshevsky</option>
	<option value="data/bruehlVphilidor.json">Bruehl v. Philidor</option>  
	<option value="data/brandtleyVmatthew211220.json">Brandtley v. Matthew </option>
</select>
<div id="moves"></div>
</div>

<script src="scripts/pieces.js"></script> 
<script src="d3-lib/d3/d3.min.js"></script>
<script>
	

	const size = 8
	var margin = {'right':30, 'left':3, 'top':3, 'bottom':30}


	// squares data generation
	const data = Array.from(Array(size**2).keys())	

	// scales + axes
	var xScale = d3.scaleLinear()
	.domain([25,50,400]).range([25,50,400])
	let xAxisTickLabels = ['a','b','c','d','e','f','g','h'];
  	xAxis = d3.axisBottom(xScale)
  		.tickFormat((d,i) => xAxisTickLabels[i])

  	var yScale = d3.scaleLinear()
  		.domain([25,50,400]).range([25,50,400])
  	let yAxisTickLabels = ['1','2','3','4','5','6','7','8']
  	yAxis = d3.axisRight(yScale)
  		.tickFormat((d,i) => yAxisTickLabels[i])

  	// construct hash of board position names and coordinates
  	var positions = {}
	var i = 0
	var yReverse = yAxisTickLabels.reverse()
	while(i < xAxisTickLabels.length) {
	    var j = 0
		while(j < yAxisTickLabels.length) {
			rank = yReverse[j]
			file = xAxisTickLabels[i]
			x = i * (rectWidth) + (rectWidth/2)+squareStrokeWidth
			y = rank * (rectHeight) - (rectHeight/2)+squareStrokeWidth
			yReverse = yAxisTickLabels.reverse()
			rank = yAxisTickLabels[j]
			position_name = file.concat('',rank)
		    positions[position_name] = [x,y]			
			yReverse = yAxisTickLabels.reverse()		    
 		    j++
		}
		i++
	}
	

  	function getPositionLabel(d){
	  	//iterate on data
	  	// return 'E5', 'E4', etc.
  		f = xAxisTickLabels[Math.floor(d/8)]
  		r = yAxisTickLabels[d % 8]
  		return f.concat('', r)	  	
  	}
  	
  	
  	var svg = d3.select('body')
  		.append('svg')
  		.attr('height', (rectHeight * size) + margin.top + margin.bottom)
  		.attr('width', (rectWidth * size) + margin.right + margin.left)
  	
  	// board 
  	svg.append("g")
  		.attr("transform", "translate("+squareStrokeWidth+","+squareStrokeWidth+")")
  		.selectAll('rect')
  		.data(data)
  		.enter()
  		.append('rect')
        .attr('x', function (d) {
			return Math.floor(d / size) * rectWidth 
        })
  		.attr('y', function(d){
  			return (d % size) * rectHeight
  		})
  		.attr('width', rectWidth)
  		.attr('height', rectHeight)
  		.attr('stroke-width', squareStrokeWidth)
  		.attr('stroke', squareStrokeColor)
  		.attr('fill', function(d){
	  		if( Math.floor(d / size) % 2 == 0 ){
		  		if ((d % 2) == 0){
			  		return lightSquareColor		  		
		  		}
		  		return darkSquareColor
		  	}
	  		if ((d % 2) == 0){
				return darkSquareColor		  		
		  	}
		  	return lightSquareColor
  		})
  		.on('mouseover', function(d){
  			square = getPositionLabel(d)
	  		s = 'Position: '		
	  		d3.select("#positionDisplay")
	  			.text(s.concat('',square))
  		})
  		.on('mouseout',function(){
  			d3.select("#positionDisplay")
  			.text('Position: ')
  		})
	
	// axes	
  	svg.append("g")
  		.attr("transform", "translate(-22,"+((rectWidth*size)+squareStrokeWidth)+")")
  		.call(xAxis)
  		.call(g => g.select(".domain").remove())  		

  	svg.append("g")
	  	.attr("transform", 
	  		"translate("+((rectHeight*size)+squareStrokeWidth)+",-22)") 
  		.call(yAxis)
  		.call(g => g.select(".domain").remove())  		
  	
  	// annotate square centers
	svg.append("g")
		.selectAll("circle")
		.data(Array.from(Object.keys(positions)))
		.enter()
		.append('circle')
		.attr('cx', function(d){
			return positions[d][0]
		})
		.attr('cy', function(d){
			return positions[d][1]
		})
		.attr('r', function(d){
			return 11
		})
		.attr('stroke', 'rgba(.5,.5,.5,.2)')
		.attr('fill', 'rgba(1.0,1.0,1.0,.1)')  	
  	
  	
  	// board position annotations
  	svg.append("g")
  		.selectAll("text")
  		.data(data)
  		.enter()
  		.append("text")
  		.attr('x', function(d){
	  		return (Math.floor(d / size) * rectWidth) + 21.5
   		})
  		.attr('y', function(d){	
	  		m = d % size
	  		return (m * rectHeight) + 32.5
  		})
  		.text(function(d){
	  		return getPositionLabel(d)
  		})

  	//  container for pieces
	svg.append("g").attr("id", "pieces")

    Promise.all([  // load default game. 
        d3.json('data/kasparovVkarpov.json'),
        d3.json('data/startBoard.json')
    ]).then(
        d => ready(d[0], d[1])
    );


	function ready(gameData, aBoard){	
				
        d3.select("#gameSelect").on("change", function (d) {
            var selectedOption = d3.select(this).property("value")
			Promise.all([
		        d3.json(selectedOption),
		        d3.json('data/startBoard.json')
		    ]).then(
		        d => loadGame(d[0], pieces, d[1])
		    )                
            
        })		
			
		loadGame(gameData, pieces, aBoard)
	}

	function loadPieces(pieces, aBoard){
				
		var pieces = Array.from(Object.keys(aBoard))  			
		
		d3.select("#pieces").selectAll("path").remove()
		
		var chessPieces = d3.select("#pieces")
			.selectAll("path")
			.data(pieces)
			
		chessPieces.enter()
			.append("path")
			.attr("id", function(d){ return d })
			.attr("transform", function(d){
	  			return "translate("+
	  			(positions[aBoard[d].position][0]-25)
	  			+","+
	  			(positions[aBoard[d].position][1]-24)
	  			+")"			
			})
			.attr("fill", function(d){ 
				return pieceColors[aBoard[d].fill]
			})
			.attr("stroke", function(d){ 
				return pieceColors[aBoard[d].stroke] 				
			})
			.attr("d", function(d){ 
				return piecePaths[aBoard[d].path]
			})	
			
			return pieces			
	}
	
	function loadGame(gameData, pieces, aBoard){
		
		pieces = loadPieces(pieces, aBoard)						
		
		d3.select("#moves").selectAll("div").remove()
        d3.select("#moves")
        	.selectAll("div")
			.data(gameData.moves)        	
        	.enter()
        	.append("div")
			.attr("id", function(d,i){
				return "move"+i
			})
        	.text(function(d,i){
				return d
        	})	
		
		var move = 0		
        var lastMove = gameData.moves.length
    	        
		// piece movement
		d3.select("#start").attr("disabled", null)		
		d3.select("#start").on("click", function() {
			
  			this_move = gameData.moves[move]
  			var parsedMoves = parseMove(move, this_move, aBoard)
			console.log(parsedMoves)

			var piece = parsedMoves[0][0]
			var nextPosition = parsedMoves[0][1]
			var newPosition = positions[nextPosition] //x,y coords
			d3.select("#start").attr("disabled", "disabled")
			
			
			// color move squares		
			d3.select("#move"+move)
				.transition()
				.style("background-color", "#c2d8d7")		

			d3.select("#move"+(move-1).toString())
				.transition()
				.style("background-color", "white")		
			
			var scrollMoveToView = document.getElementById("move"+move);
			scrollMoveToView.scrollIntoView();
			
			
			d3.select("#"+piece) //animate movement
				.transition()
				.attr("transform", "translate("+(newPosition[0]-25)+","+
  			(newPosition[1]-24)+")")
  				.on("end",function(d){
	  				if (parsedMoves.length == 2){ // capture or castle
		  				if (parsedMoves[1][1]=="x"){
			  				// capture
			  				var capturedPiece = parsedMoves[1][0]
		  					console.log("capture of "+ aBoard[capturedPiece].name + "!")
							delete aBoard[capturedPiece]
							pieces.splice (pieces.indexOf(capturedPiece), 1)
							// fade out & remove captured piece
							d3.select("#pieces").select("path#"+capturedPiece)
								.transition()
								.attr("stroke", "rgba(0,0,0,0)")
								.attr("fill", "rgba(0,0,0,0)")
								.remove()	  						  					
		  				}
		  				else {
			  				// castling move
		  					var piece = parsedMoves[1][0]
							var nextPosition = parsedMoves[1][1]								
							var newPosition = positions[nextPosition] //x,y coords
							aBoard[piece].position = nextPosition
							d3.select("#"+piece) //animate movement
								.transition()
								.attr("transform", "translate("+(newPosition[0]-25)+","+
				  			(newPosition[1]-24)+")")			  				
		  				}
	  				}
	  				if (move!=lastMove){ // detect endgame
	  					d3.select("#start").attr("disabled", null)		  				
	  				}

  				})
  				
  			aBoard[piece].position = nextPosition					
			move +=1 //advance to next move of game					
		});            
	}


	
    </script>
</body>
